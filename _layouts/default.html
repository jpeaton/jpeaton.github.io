<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>{{ page.title }} | {{ site.title }}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="/assets/main.css" />
  </head>

  <body>
    <main class="terminal">
      {{ content }}
    </main>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const container = document.querySelector("main.terminal");
        container.classList.add("boot");
        if (!container) return;
      
        // Respect reduced motion
        if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
      
        // Only do the special "command + pause" on the homepage
        const isHome = window.location.pathname === "/" || window.location.pathname.endsWith("/index.html");
      
        // Speeds
        const CHAR_DELAY_MS = 6;        // typing speed
        const NODE_PAUSE_MS = 40;       // pause between text nodes
        const COMMAND_PAUSE_MS = 450;   // pause after command finishes typing
      
        // Create ONE cursor for the whole page
        const cursor = document.createElement("span");
        cursor.id = "term-cursor";
        cursor.classList.add("idle");
        cursor.textContent = "█"; // block is via background
      
        // Collect all text nodes (skip code/pre)
        const walker = document.createTreeWalker(
          container,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node) {
              if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
              const parent = node.parentElement;
              if (parent && (parent.closest("pre") || parent.closest("code"))) return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
      
        const nodes = [];
        let n;
        while ((n = walker.nextNode())) nodes.push(n);
      
        // Save originals and clear text
        const originals = nodes.map(node => node.nodeValue);
        nodes.forEach(node => (node.nodeValue = ""));
        // Hide elements that would otherwise appear before their text types
        const hideSelectors = "img, ul, ol, li, h1, h2, h3, h4, h5, h6, p, blockquote";
        const hideEls = Array.from(container.querySelectorAll(hideSelectors));
        
        // Hide them all initially (blank screen)
        hideEls.forEach(el => el.classList.add("hidden-until-typed"));
        
        // Sort hidden elements in DOM order so we can reveal progressively
        hideEls.sort((a, b) => {
          if (a === b) return 0;
          const pos = a.compareDocumentPosition(b);
          return (pos & Node.DOCUMENT_POSITION_FOLLOWING) ? -1 : 1;
        });
        
        let revealIndex = 0;
        
        // Reveal all hidden elements that come before (or are) the current element
        function revealUpTo(currentEl) {
          while (revealIndex < hideEls.length) {
            const el = hideEls[revealIndex];
            // If el is before currentEl or is currentEl, reveal it
            const pos = el.compareDocumentPosition(currentEl);
        
            const elBeforeCurrent =
              (pos & Node.DOCUMENT_POSITION_FOLLOWING) === 0 && el !== currentEl
                ? false
                : (pos & Node.DOCUMENT_POSITION_FOLLOWING) !== 0 || el === currentEl;
        
            // Simpler: reveal until we reach currentEl in order
            el.classList.remove("hidden-until-typed");
            el.classList.add("revealed");
            revealIndex++;
        
            if (el === currentEl) break;
          }
        }
        if (nodes.length > 0 && nodes[0].parentElement) {
        nodes[0].parentElement.appendChild(cursor);
        }
      
        // Helper: move cursor to "insertion point" after a specific text node
       function getRevealTarget(node) {
          const el = node.parentElement;
          if (!el) return null;
        
          // Reveal at a "block-ish" level so bullets/images in that section appear at the right time
          return el.closest("li, p, h1, h2, h3, h4, h5, h6, blockquote, ul, ol, figure") || el;
        }
        
        function moveCursorToNode(node) {
          const textParent = node.parentElement;
          if (!textParent) return;
        
          const revealTarget = getRevealTarget(node);
          if (revealTarget) revealTarget.classList.add("revealed");
        
          // Also reveal any images inside the revealed block (so they don't show early)
          if (revealTarget) {
            revealTarget.querySelectorAll("img").forEach(img => img.classList.add("revealed"));
          }
        
          // Cursor should live at the true insertion point: end of the element being typed into
          textParent.appendChild(cursor);
        }
        
          // Reveal elements up to this one (so images/lists above it appear at the right time)
          revealUpTo(el);
        
          // Keep cursor at the end of the currently-typing element
          el.appendChild(cursor);
        }
      
        let nodeIndex = 0;
        let charIndex = 0;
      
        // We pause after the first H1 on homepage (your "./run_website_for_jeremiah.sh")
        // We'll detect that by checking the first time we finish typing inside an H1.
        let didCommandPause = false;
      
        // Fake loading output (homepage only)
        const loadingLines = [
          "[✓] initializing environment",
          "[✓] loading configuration",
          "[✓] mounting filesystem",
          "[✓] starting services",
          "[✓] ready"
        ];
      
        let isLoadingPhase = false;
        let loadingIndex = 0;
      
        // Create a loading container
        const loadingBlock = document.createElement("div");
        loadingBlock.className = "loading-block";
      
        function typeLoadingLine(text, callback) {
        const lineEl = document.createElement("div");
        container.appendChild(lineEl);
      
        let i = 0;
        cursor.classList.remove("idle");
      
        function step() {
          if (i < text.length) {
            lineEl.textContent += text[i];
            moveCursorToNode(lineEl.firstChild || lineEl);
            i++;
            setTimeout(step, 20);
          } else {
            cursor.classList.add("idle");
            setTimeout(callback, 350);
          }
        }
      
        step();
      }
          
        function typeNextChar() {
          if (nodeIndex >= nodes.length) {
            cursor.classList.add("idle");
            return;
          }
      
          cursor.classList.remove("idle"); // solid while actively typing
      
          const node = nodes[nodeIndex];
          const full = originals[nodeIndex];
      
          node.nodeValue = full.slice(0, charIndex + 1);
          moveCursorToNode(node);

          container.classList.remove("boot");
          
          charIndex++;
      
          if (charIndex < full.length) {
            setTimeout(typeNextChar, CHAR_DELAY_MS);
            return;
          }
      
          // Finished this node
          const parentEl = node.parentElement;
      
          nodeIndex++;
          charIndex = 0;
      
          // If this text node lived in the first H1 on the homepage, do the "command executing" pause once
          if (isHome && !didCommandPause && parentEl && parentEl.tagName === "H1") {
        didCommandPause = true;
      
        // Create a loading area right after the first H1 (so it appears near the top)
        const h1 = parentEl;
        const loadingArea = document.createElement("div");
        loadingArea.id = "loading-area";
        h1.insertAdjacentElement("afterend", loadingArea);
      
        const loadingLines = [
          "[✓] initializing",
          "[✓] sitting upright",
          "[✓] tightening facial expression",
          "[✓] locked in",
          "[✓] we're so back"
        ];
      
        const LINE_CHAR_DELAY_MS = 18;   // typing speed for loading lines
        const LINE_PAUSE_MS = 450;       // pause between loading lines
        const FINAL_PAUSE_MS = 800;      // pause after "ready" before rest of page continues
      
        // Types a single loading line using a TEXT NODE (avoids cursor getting baked into text)
        function typeLoadingLine(line, done) {
          const lineEl = document.createElement("div");
          const textNode = document.createTextNode("");
          lineEl.appendChild(textNode);
          loadingArea.appendChild(lineEl);
      
          let i = 0;
          cursor.classList.remove("idle");
      
          function step() {
            if (i < line.length) {
              textNode.nodeValue += line[i];
              // Keep cursor at the true insertion point
              lineEl.appendChild(cursor);
              i++;
              setTimeout(step, LINE_CHAR_DELAY_MS);
            } else {
              cursor.classList.add("idle");
              setTimeout(done, LINE_PAUSE_MS);
            }
          }
      
          step();
        }
      
        // Run all loading lines (~5 seconds total depending on delays)
        let idx = 0;
        cursor.classList.add("idle");
      
        setTimeout(function run() {
          if (idx >= loadingLines.length) {
            setTimeout(typeNextChar, FINAL_PAUSE_MS);
            return;
          }
          typeLoadingLine(loadingLines[idx], () => {
            idx++;
            run();
          });
        }, 600);
      
        return;
      }
      
          cursor.classList.add("idle");
          setTimeout(typeNextChar, NODE_PAUSE_MS);
        }
      
        // Start with cursor at top
        cursor.classList.add("idle");
        typeNextChar();
      });
  </script>
  </body>
</html>
