<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>{{ page.title }} | {{ site.title }}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="/assets/main.css" />
  </head>

  <body>
    <main class="terminal">
      {{ content }}
    </main>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const container = document.querySelector("main.terminal");
        if (!container) return;
      
        // Respect reduced motion
        if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
      
        container.classList.add("boot");
      
        const isHome =
          window.location.pathname === "/" ||
          window.location.pathname.endsWith("/index.html");
      
        // Speeds
        const CHAR_DELAY_MS = 8;
        const NODE_PAUSE_MS = 50;
      
        // One cursor for the whole page
        const cursor = document.createElement("span");
        cursor.id = "term-cursor";
        cursor.classList.add("idle");
        cursor.textContent = "█";
      
        // Hide “block-ish” elements so they don’t pop in before typing reaches them
        const hideSelectors = "img, p, blockquote, h1, h2, h3, h4, h5, h6";
        const hideEls = Array.from(container.querySelectorAll(hideSelectors));
        hideEls.forEach(el => el.classList.add("hidden-until-typed"));

        // --- Image anchors: make the typer "hit" images in-flow ---
        const imgs = Array.from(container.querySelectorAll("img"));
        imgs.forEach(img => {
          // prevent duplicates
          if (img.previousSibling && img.previousSibling.nodeType === Node.ELEMENT_NODE &&
              img.previousSibling.classList.contains("img-anchor")) return;
        
          const anchor = document.createElement("span");
          anchor.className = "img-anchor";
          anchor.textContent = "."; // must be non-whitespace so TreeWalker doesn't reject it
          img.parentNode.insertBefore(anchor, img);
        });
        
        hideEls.sort((a, b) => {
          if (a === b) return 0;
          const pos = a.compareDocumentPosition(b);
          return (pos & Node.DOCUMENT_POSITION_FOLLOWING) ? -1 : 1;
        });
        
        let revealIndex = 0;
        
        function revealUpTo(targetEl) {
          while (revealIndex < hideEls.length) {
            const el = hideEls[revealIndex];
            el.classList.remove("hidden-until-typed");
            el.classList.add("revealed");
            revealIndex++;
            if (el === targetEl) break;
          }
        }
        
        // Collect text nodes (skip pre/code)
        const walker = document.createTreeWalker(
          container,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node) {
              if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
              const parent = node.parentElement;
              if (parent && (parent.closest("pre") || parent.closest("code"))) return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
      
        const nodes = [];
        let node;
        while ((node = walker.nextNode())) nodes.push(node);
      
        const originals = nodes.map(n => n.nodeValue);
        nodes.forEach(n => (n.nodeValue = ""));
      
        function revealBlockForTextNode(textNode) {
          const el = textNode.parentElement;
          if (!el) return;
        
          const block =
            el.closest("li, p, h1, h2, h3, h4, h5, h6, blockquote") || el;
        
          // KEY CHANGE:
          // Reveal everything up to the current block in DOM order,
          // so image-only blocks pop in "as you reach them"
          revealUpTo(block);
        
          // Keep cursor at the real insertion point
          el.appendChild(cursor);
        }
      
        // Put cursor somewhere visible immediately
        container.prepend(cursor);
      
        let nodeIndex = 0;
        let charIndex = 0;
        let didHomePause = false;
      
        function runHomeLoadingBlock(afterEl, done) {
          const loadingArea = document.createElement("div");
          loadingArea.id = "loading-area";
          afterEl.insertAdjacentElement("afterend", loadingArea);
      
          const lines = [
            "[✓] initializing",
            "[✓] reading the room",
            "[✓] adjusting accordingly",
            "[✓] locked in",
            "[✓] we’re so back"
          ];
      
          const LINE_CHAR_DELAY_MS = 18;
          const LINE_PAUSE_MS = 350;
          const FINAL_PAUSE_MS = 600;
      
          let i = 0;
      
          function typeLine(line, cb) {
            const lineEl = document.createElement("div");
            const t = document.createTextNode("");
            lineEl.appendChild(t);
            loadingArea.appendChild(lineEl);
      
            let k = 0;
            cursor.classList.remove("idle");
      
            function step() {
              if (k < line.length) {
                t.nodeValue += line[k++];
                lineEl.appendChild(cursor);
                setTimeout(step, LINE_CHAR_DELAY_MS);
              } else {
                cursor.classList.add("idle");
                setTimeout(cb, LINE_PAUSE_MS);
              }
            }
            step();
          }
      
          (function next() {
            if (i >= lines.length) {
              setTimeout(done, FINAL_PAUSE_MS);
              return;
            }
            typeLine(lines[i++], next);
          })();
        }
      
        function typeNextChar() {
          if (nodeIndex >= nodes.length) {
            container.classList.remove("boot");
            cursor.classList.add("idle");

            // reveal whatever never got triggered
            hideEls.forEach(el => {
              el.classList.remove("hidden-until-typed");
              el.classList.add("revealed");
            });
            
            return;
          }
      
          cursor.classList.remove("idle");
      
          const n = nodes[nodeIndex];
          const full = originals[nodeIndex];
      
          n.nodeValue = full.slice(0, charIndex + 1);
          revealBlockForTextNode(n);
      
          container.classList.remove("boot");
      
          charIndex++;
      
          if (charIndex < full.length) {
            setTimeout(typeNextChar, CHAR_DELAY_MS);
            return;
          }
      
          // finished this text node
          const parentEl = n.parentElement;
      
          nodeIndex++;
          charIndex = 0;
      
          // Do the home “pause + loading” once, right after the first H1 finishes
          if (isHome && !didHomePause && parentEl && parentEl.tagName === "H1") {
            didHomePause = true;
            cursor.classList.add("idle");
            runHomeLoadingBlock(parentEl, () => setTimeout(typeNextChar, NODE_PAUSE_MS));
            return;
          }
      
          cursor.classList.add("idle");
          setTimeout(typeNextChar, NODE_PAUSE_MS);
        }
      
        typeNextChar();
      });
  </script>
  </body>
</html>
